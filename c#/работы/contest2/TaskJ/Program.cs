using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

/// Дана функция F(x, y) = A*sin(B*x) + C*(cos(D*y))3, где A, B, C, D - коэффициенты. x и y могут принимать только целые 
/// значения от -50 до 50 (обе границы включительно). Также рассмотрим функцию G(x, y) = [F(x, y)] - она возвращает целую 
/// часть функции F(x, y) (c округлением до ближайшего целого). Необходимо найти все такие пары x и y, в которых функция G принимает 
/// наибольшее значение, и вывести количество таких пар и это наибольшее значение.
/// A, B, C, D - четыре вещественных неотрицательных числа, каждое с новой строки. При получении неверных данных необходимо вывести 
/// wrong и сразу же завершить выполнение программы.
/// Два числа, каждое на новой строке Количество найденных пар - целое число. Наибольшее значение функции при найденных парах x и y.

namespace TaskJ
{
	class Program
	{
		/// <summary>
		/// Метод вычисляет данную в условии функцию по входящим значениям переменных X и Y и коэффициентов A, B, C и D, округляет ее до ближейшего целого 
		/// с помощью Math.Round и возвращает в точку вызова.
		/// </summary>
		/// <param name="variableX"> Переменная Х. </param>
		/// <param name="variableY"> Переменная У. </param>
		/// <param name="coeffA"> Первый коэффициент. </param>
		/// <param name="coeffB"> Второй коэффициент. </param>
		/// <param name="coeffC"> Третий коэффициент. </param>
		/// <param name="coeffD"> Четвертый коэффициент. </param>
		/// <returns> Метод возвращает округленное значение функции. </returns>

		static int Func(int variableX, int variableY, double coeffA, double coeffB, double coeffC, double coeffD)
		{
			return (int)Math.Round(coeffA * Math.Sin(coeffB * variableX) + coeffC * (Math.Cos(coeffD * variableY)) * (Math.Cos(coeffD * variableY)) * (Math.Cos(coeffD * variableY)));
		}

		/// <summary>
		/// Метод находит максимальное значение функции и количество пар переменных Х и У, на которых получается это значение, с помощью перебора всех возможных
		/// пар переменных в двух вложенных циклах for от -50 до 50 включительно с проверкой в условном операторе if, больше ли текущее значение функции 
		/// (происходит вызов метода, вычисляющего значение функции для данных i и j) запомненного максимума или равно ему, с обновлением количества пар 
		/// и максимума в зависимости от этого.
		/// </summary>
		/// <param name="coeff1"> Первый коэффициент. </param>
		/// <param name="coeff2"> Второй коэффициент. </param>
		/// <param name="coeff3"> Третий коэффициент. </param>
		/// <param name="coeff4"> Четвертый коэффициент. </param>
		/// <param name="funcMax"> Переменная для максимального значения функции. </param>
		/// <param name="numberOfPairs"> Переменная для количества пар Х и У, дающих наибольшее значение функции. </param>

		static void FindFuncMax(double coeff1, double coeff2, double coeff3, double coeff4, out double funcMax, out int numberOfPairs)
		{
			// Переменная для максимума изначально равна минимальному значению типа double, количество пар равно 0;

			funcMax = double.MinValue;
			numberOfPairs = 0;

			// Вложенные циклы для перебора всех возможных пар переменных.

			for (int i = -50; i <= 50; i++)
			{
				for (int j = -50; j <= 50; j++)
				{
					// Вызывается метод, вычисляющий функцию, если текущее значение функции больше максимума, максимум приравнивается к значению функции, 
					// а количество пар - к 1.

					if (Func(i, j, coeff1, coeff2, coeff3, coeff4) > funcMax)
					{
						numberOfPairs = 1;
						funcMax = Func(i, j, coeff1, coeff2, coeff3, coeff4);
					}

					// Вызывается метод, вычисляющий функцию, если текущее значение функции равно максимуму, количество пар увеличивается на 1.

					else
					{
						if (Func(i, j, coeff1, coeff2, coeff3, coeff4) == funcMax)
						{
							numberOfPairs++;
						}
					}
				}
			}
		}

		/// <summary>
		/// Метод считывает строку и пытается преобразовать ее переменную вещественного типа
		/// с помощью метода TryParse, возвращает через return значение переменной и через out переменную булевого типа, показывающую,
		/// удалось ли преобразование (корректны ли входные данные).
		/// </summary>
		/// <param name="input"> Считываемая переменная. </param>
		/// <param name="readIn"> Переменная булевого типа, отражающая корректность вводных данных для переменной. </param>
		/// <returns> In - считываемую переменную. /returns>

		static double Read(out bool readIn)
		{
			double input;
			readIn = double.TryParse(Console.ReadLine(), out input);
			return input;
		}

		/// <summary>
		/// Объявляются переменные для считываемых коэффициентов, для максимального значения функции, для количества подходящих пар и для проверки корректности 
		/// введенных данных. Вызывается метод считывания и осуществляется проверка корректности введенных данных для каждого из четырех коэффициентов, если
		/// все данные корректны - вызыввается метод, находящий максимум функции и количество подходящих пар, а затем их значения выводятся.
		/// </summary>

		static void Main(string[] args)
		{
			// Переменные вещественного типа для четырех коэффициентов и максимального значения функции.

			double coeffA, coeffB, coeffC, coeffD, max;

			// Переменная целого типа для количества подходящих пар.

			int numberOfPairs;

			// Переменные булевого типа для проверки корректности вводимых данных.

			bool readA, readB, readC, readD;


			// Вызов метода считывания для первого коэффициента.

			coeffA = Read(out readA);


			// Для каждого коэффициента вызывается считывание, затем в условном операторе проверяется корректность данных(соответствие типа и правильность 
			// значения - коэффициенты вещественные и неотрицательные), если они корректны - происходит дальнейшее считывание, иначе - выводится строка wrong 
			// и программа прекращает работать.

			if (readA && coeffA >= 0)
			{
				coeffB = Read(out readB);

				if (readB && coeffB >= 0)
				{
					coeffC = Read(out readC);

					if (readC && coeffC >= 0)
					{
						coeffD = Read(out readD);

						if (readD && coeffD >= 0)
						{
							// Если все данные корректны, происходит вызов метода, находящего максимум функции и количество пар переменных, дающих максимум.

							FindFuncMax(coeffA, coeffB, coeffC, coeffD, out max, out numberOfPairs);

							// Вывод данных: количество пар и максимум на разных строчках.

							Console.WriteLine($"{numberOfPairs}\n{max}");
						}
						else
						{
							Console.WriteLine("wrong");
						}
					}
					else
					{
						Console.WriteLine("wrong");
					}
				}
				else
				{
					Console.WriteLine("wrong");
				}
			}
			else
			{
				Console.WriteLine("wrong");
			}
		}
	}
}
