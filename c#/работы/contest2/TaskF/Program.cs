using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

/// Напишите программу, шифрующую текст с помощью шифра Цезаря. Для этого реализуйте метод, возвращающий зашифрованную 
/// строку word как параметр с модификатором out.
/// static void Caesar(string word, int shift, out string ciphertext)) 
/// Шифр Цезаря – это вид шифра подстановки, в котором каждый символ в открытом тексте заменяется символом, находящимся 
/// на некотором постоянном числе позиций правее(или левее) него в алфавите. При этом последняя буква алфавита переходит в первую.
/// В первой строке вводится неотрицательное число N - количество слов, которое необходимо зашифровать.
/// Во второй сроке вводится целое число K, величина на которую надо сдвинуть.Если К положительное, то сдвиг производится вправо, 
/// если отрицательное, то влево.
/// В следующих N строках указано по одному слову, состоящему только из латинских букв нижнего регистра.
/// Для каждого введенного слова вывести его результат применения к нему шифра Цезаря со сдвигом на K.
/// В случае, если входные данные не соответствуют условию, выведите строку wrong и сразу же завершите выполнение программы.

namespace TaskF
{
	class Program
	{
		/// <summary>
		/// Метод преобразует входящую строку в новую строку с использованием переменной shift по правилу шифрования Цезаря.
		/// </summary>
		/// <param name="word"> Входящая строка. </param>
		/// <param name="shift"> Число букв, на которое осуществляется сдвиг. </param>
		/// <param name="ciphertext"> Новая строка - изначальная в шифре Цезаря. </param>

		static void Caesar(string word, int shift, out string ciphertext)
		{
			// Строка для зашифрованного слова, изначально пустая.

			ciphertext = String.Empty;

			// Вспомогательная строка с прописными буквами латинского алфавита.

			string arrayOfLetters = "abcdefghijklmnopqrstuvwxyz";

			// Если вводится отрицательный сдвиг, мы приводим его к положительному с таким же остатком при делении на 26.

			while (shift < 0)
			{
				shift += 26;
			}

			// Для каждой буквы изначальной строки соответствующая ей буква новой строки "подклеивается" к новой строке с помощью конкатинации строк по правилу
			// новая буква - это элемент массива латинских букв (вспомогательная строка), стоящий на месте (x + shift%26) %26, где х - номер буквы изначального слова
			// в алфавите, где буквы пронумированы от 0 (для этого из кода символа слова в таблице ASCII вычитаем 97 - код буквы а).

			for (int i = 0; i < word.Length; i++)
			{
				ciphertext += arrayOfLetters[(((int)word[i] - 97 + shift % 26) % 26)];
			}
		}

		/// <summary>
		/// Метод проверяет, есть ли в слове символы, отличающиеся от прописных латинских букв, в цикле сравнивая код каждой буквы слова в таблице ASCII с 
		/// кодами прописных латинских букв, возвращает false, если есть, и true, если нет.
		/// </summary>
		/// <param name="word"> Входящее слово, для которого проверяются символы. </param>
		/// <returns> Метод возвращает булевое true или false в зависимости от результатов проверки символов слова. </returns>

		static bool WordCheck(string word)
		{
			for (int i = 0; i < word.Length; i++)
			{
				if (word[i] < 97 || word[i] > 122)
				{
					return false;
				}
			}
			return true;
		}

		/// <summary>
		/// Метод считывает строку и пытается преобразовать ее переменную целочисленного типа
		/// с помощью метода TryParse, возвращает через return значение переменной и через out переменную булевого типа, показывающую,
		/// удалось ли преобразование (корректны ли входные данные).
		/// </summary>
		/// <param name="In"> Считываемая переменная. </param>
		/// <param name="ReadIn"> Переменная булевого типа, отражающая корректность вводных данных для переменной. </param>
		/// <returns> In - считываемую переменную. /returns>

		static int ReadInt(out bool ReadIn)
		{
			int In;
			ReadIn = int.TryParse(Console.ReadLine(), out In);
			return In;
		}

		/// <summary>
		/// 
		/// </summary>

		static void Main(string[] args)
		{
			// Переменные целого типа для входных данных: количества шифруемых слов и ключа шифра (сдвиг по алфавиту).

			int wordsNumber, shift;

			// Переменные булевого типа для проверки корректности вводимых данных для числа слов и ключа шифра.

			bool readNumber, readShift, checkWord;

			// Переменные для считываемого слова и зашифрованного слова.

			string wordToCaesar, result;

			// Вызов метода считывания данных с консоли.

			wordsNumber = ReadInt(out readNumber);

			// Проверка корректности введенных данных.

			if (readNumber)
			{
				// Вызов метода считывания данных с консоли.

				shift = ReadInt(out readShift);

				// Проверка корректности введенных данных.

				if (readShift)
				{
					// Вызов метода считывания данных с консоли по одному слову в цикле столько раз, сколько слов нам нужно считать.

					for (int i = 0; i < wordsNumber; i++)
					{
						wordToCaesar = Console.ReadLine();

						// Проверка корректности введенных данных.

						if (WordCheck(wordToCaesar))
						{
							// Вызов метода шифрования слова.

							Caesar(wordToCaesar, shift, out result);

							// Вывод полученного зашифрованного слова.

							Console.WriteLine(result);
						}
						else
						{
							// Вывод строки wrong и завершение работы программы.

							Console.WriteLine("wrong");
							break;
						}
					}
				}
				else
				{
					// Вывод строки wrong и завершение работы программы.

					Console.WriteLine("wrong");
				}
			}
			else
			{
				// Вывод строки wrong и завершение работы программы.

				Console.WriteLine("wrong");
			}
		}
	}
}
