using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

/// Петя узнал про простую задачу в которой проверяется на то, лежит ли число в диапазоне [0.(3)*1.(1); 0.(6)*0.(9)), но в троичной системе. 
/// На всякий случай заметим, что 0.(6)*0.(9) == 1-0.(3)*1.(1).
/// На вход подаётся число n не больше 255 - количество разрядов после 0 На каждой из n новых строк — 1 разряд числа в троичной системе счисления
/// На выходе выдать ответ — Yes, если лежит в промежутке или номер разряда, на котором число перестало попадать в промежуток.
/// Запрещено использовать циклы

/// ПРИМЕЧАНИЕ К РЕШЕНИЮ
/// Данное в условии неравенство, хоть и выглядит пугающе, на самом деле равносильно довольно простому условию, а именно вводимое число = 0,(1).
/// Как это получается? Рассмотрим левую границу интервала - 0,(3)*1,(1)in3 = 1\3 * 1,(1)in3 = 3^(-1)*1,(1)in3 = 0,1in3 * 1,(1)in3 = 0,(1).
/// Рассмотрим правую границу интервала - 1-0.(3)*1.(1)in3 = 1-0,(1)in3 = 1in3 - 0,(1)in3 = 0,(1)2.
/// То есть наш интервал равносилен интервалу [0,(1); 0,(1)2), несложно заметить, что единственное удовлетворяющее этому число - 0,(1),
/// поэтому в дальнейшем решении мы будем проверять, являются ли все вводимые разряды числа после запятой единицами, и только в таком случае будем
/// считать, что число удовлетворяет условию, иначе же будем запоминать и выводить номер первого по счету разряда, отличного от единицы.

namespace TaskG
{
	class Program
	{
		/// <summary>
		/// Данный рекурсивный метод помогает без использования циклов считать и проверить корректность нескольких строк входных данных, число которых
		/// считывается в методе мейн и передается в этот метод как итератор. Метод, кроме того, принимает через ref значение номера считываемой 
		/// строки, строку с ответом и переменную флаг. В методе мы проверяем корректность вводимых данных, если они неверны - выводим строку wrong
		/// и завершаем работу программы, иначе сравниваем значение каждой считанной строки с единицей, если какая-то из строк не равна 1 и значение 
		/// переменной флага не менялось, то мы запоминаем номер этой строки и меняем значение флага (то есть отмечаем первое несовпадение с 1),
		/// далее вызываем этот же метод от итератора, уменьшенного на 1.
		/// </summary>
		/// <param name="iterator"> Переменная для обозначения глубины рекурсии. </param>
		/// <param name="index"> Переменная для подсчета порядкового номера каждой входящей строки. </param>
		/// <param name="result"> Переменная для ответа. </param>
		/// <param name="flag"> Переменная для того, чтобы запоминать только первый несовпадающий с 1 элемент. </param>
		/// <returns> Метод возвращает булевое false, если итератор стал равен 0, либо вызов себя же от итератора-1, если итератор больше 0. </returns>

		static bool CheckInterval(uint iterator, ref uint index, ref string result, ref bool flag)
		{
			// Проверка, не стал ли итератор равен нулю. Если стал, рекурсию нужно останавливать.

			if (iterator == 0)
			{
				return false;
			}

			// Переменная булевого типа для проверки корректности ввода каждого числа.

			bool readDigit;

			// Вызов метода чтения для переменной, хранящей одну входящую цифру.

			uint digit = Read(out readDigit);

			// Проверка корректности вводимых данных: это должна быть цифра в троичной системе счисления, то есть 0, 1 или 2.

			if (!readDigit || digit > 2)
			{
				// Если входные данные некорректны, выводится строка wrong и программа завершает работу.

				Console.WriteLine("wrong");
				Environment.Exit(0);
			}
			else
			{
				// Если данные корректны, увеличиваем номер входящей строки на 1.

				index++;

				// Проверяем соответствие входящей цифры единице: если цифра не 1 и это первая такая цифра, запоминаем ее номер в ответ и изменяем 
				// переменную флаг, чтобы больше не входить в этот условный оператор.

				if (digit != 1 && flag)
				{
					result = index.ToString();
					flag = false;
				}
			}

			// Вызов того же метода от итератора, уменьшенного на 1 - осуществление в цикле, но без цикла - рекурсивно.

			return CheckInterval(--iterator, ref index, ref result, ref flag);
		}

		/// <summary>
		/// Метод считывает строку и пытается преобразовать ее переменную целочисленного беззнакового типа
		/// с помощью метода TryParse, возвращает через return значение переменной и через out переменную булевого типа, показывающую,
		/// удалось ли преобразование (корректны ли входные данные).
		/// </summary>
		/// <param name="input"> Считываемая переменная. </param>
		/// <param name="readIn"> Переменная булевого типа, отражающая корректность вводных данных для переменной. </param>
		/// <returns> In - считываемую переменную. /returns>

		static uint Read(out bool readIn)
		{
			uint input;
			readIn = uint.TryParse(Console.ReadLine(), out input);
			return input;
		}

		/// <summary>
		/// В методе мейн объявляются переменные для количества вводимых разрядов, проверки корректности ввода этой переменной, номера каждого разряда,
		/// флага о запоминании первого разряда !=1 и строки с ответом. Вызывается метод считывания количества разрядов, в условном операторе 
		/// осуществляется проверка корректности вводимых данных, если данные неверны - выводится строка wrong и работа программы завершается, иначе
		/// вызывается рекурсивный метод, который считывает по одной строке с разрядом, проверяет корректность ввода и сравнивает считанное число 
		/// с единицей, когда рекурсия останавливается, в мейн возвращается значение строки ответа, которое и выводится.
		/// </summary>

		static void Main(string[] args)
		{
			// Переменные целочисленного беззнакового типа для количества вводимых разрядов и для номера каждого конкретного вводимого разряда.

			uint numberOfDigits, index =  0;

			// Переменные булевого типа для проверки корректности вводимого числа разрядов и для запоминания номера первой! неединичной строки.

			bool readNumber, flag = true;

			// Строка для ответа, дефолтно равная yes.

			string result = "yes";


			// Вызов метода считывания для переменной количества вводимых разрядов.

			numberOfDigits = Read(out readNumber);

			// Проверка корректности вводимых данных: должно вводиться целое число от 1 до 255.

			if (readNumber && numberOfDigits > 0 && numberOfDigits < 256)
			{
				// Если данные корректны, вызывается метод, рекурсивно считывающий последующие данные - разряды числа, если он вернул значение false,
				// то он закончил работу, тогда мы выводим результат, вычисленный им.

				if(!CheckInterval(numberOfDigits, ref index, ref result, ref flag))
				{
					// Выходные данные - строка ответа, либо измененная в методе на номер первого разряда !=1, либо неизмененная и равная yes.

					Console.WriteLine($"{result}");
				}
			}
			else
			{
				// Если данные некорректны, выводится строка wrong и программа завершает работу.

				Console.WriteLine("wrong");
			}
		}
	}
}
